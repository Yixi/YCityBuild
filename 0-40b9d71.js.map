{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./data/store.ts","webpack:///../node_modules/webpack/buildin/global.js","webpack:///./model/type.ts","webpack:///./index.ts","webpack:///./scene.ts","webpack:///./model/map.ts","webpack:///../node_modules/webpack/buildin/module.js","webpack:///./trees.ts","webpack:///./model/tree.ts","webpack:///./camera.ts","webpack:///./road.ts","webpack:///./model/road.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","0","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","road","initMap","width","height","map","chunk","range","x","Math","floor","y","info","store","Store","g","this","Function","e","MESH_TYPE","canvas","document","getElementById","fps","engine","BABYLON","Engine","scene","createScene","runRenderLoop","render","textContent","getFps","toFixed","Scene","initCamera","createDefaultLight","buildRoads","buildTrees","clickToBuildRoad","mapWidth","mapHeight","ground","MeshBuilder","CreateGround","groundMaterial","StandardMaterial","diffuseColor","Color3","material","position","Vector3","webpackPolyfill","deprecate","paths","children","baseTree","createTree","removeMesh","random","forEach","tree","clone","z","mesh","meshType","TREE","addRotation","PI","trunkMaterials","leafMaterials","trunk","CreateBox","size","trunkHeight","leaf","Mesh","MergeMeshes","undefined","ArcRotateCamera","attachControl","calculateRoadType","around","roads","filter","type","ROAD","roadInfo","ROAD_TYPE","CROSSROAD","T_INTERSECTION","rotate","calculateRotationForTIntersection","HORIZONTAL","VERTICAL","CONNER","isRoad","createRoad","rebuildRoad","dispose","onPointerObservable","add","pointerInfo","PointerEventTypes","POINTERTAP","round","pickInfo","pickedPoint","rebuildSurroundingArea","ROAD_NAME","shoulderMaterials","roadBedMaterials","includes","shoulder","depth","rightShoulder","roadBed","CreatePlane","rotation","createHorizontalRoad","shoulderConner","topShoulder","createConnerRoad","shoulderConnerLeft","shoulderConnerRight","createTIntersectionRoad","shoulderConnerA","shoulderConnerB","shoulderConnerC","shoulderConnerD","createCrossroadRoad"],"mappings":"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","file":"0-40b9d71.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([5,1,2]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","import * as BABYLON from 'babylonjs'\nimport { range, chunk } from 'lodash'\nimport { MESH_TYPE } from '@root/model/type'\n\nexport interface IMapData {\n  x: number,\n  y: number,\n  mesh?: BABYLON.Mesh,\n  meshType?: MESH_TYPE,\n  info?: { [key: string]: any }\n}\n\nclass Store {\n  map: IMapData[][]\n  road: Array<[number, number]> = [\n    [45, 53],\n    [44, 53],\n    [44, 52],\n    [46, 53],\n    [46, 52],\n    [46, 51],\n    [46, 50],\n    [47, 50],\n    [48, 48],\n    [48, 49],\n    [48, 50],\n    [48, 51],\n    [48, 52],\n    [49, 50],\n    [50, 50],\n    [51, 50],\n    [51, 52],\n    [51, 51],\n    [52, 50],\n    [53, 50],\n    [53, 51],\n  ]\n\n  initMap = (width: number, height: number) => {\n    this.map = chunk(\n        range(width * height)\n        .map((value) => {\n          return {\n            x: Math.floor(value / height),\n            y: value % width,\n            info: {},\n          }\n        }),\n        width)\n  }\n}\n\nexport const store = new Store()\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","export enum MESH_TYPE {\n  ROAD,\n  TREE,\n}\n","import * as BABYLON from 'babylonjs'\nimport { createScene } from '@root/scene'\n\nconst canvas = document.getElementById('renderCanvas') as HTMLCanvasElement\nconst fps = document.getElementById('fps')\n\nconst engine = new BABYLON.Engine(canvas, true)\n\nconst scene = createScene(engine, canvas)\n\nengine.runRenderLoop(() => {\n  scene.render()\n  fps.textContent = engine.getFps().toFixed()\n})\n","import * as BABYLON from 'babylonjs'\nimport { initMap } from '@root/model/map'\nimport { buildTrees } from '@root/trees'\nimport { initCamera } from '@root/camera'\nimport { buildRoads, clickToBuildRoad } from '@root/road'\n\nexport const createScene = (engine: BABYLON.Engine, canvas: HTMLCanvasElement) => {\n  const scene = new BABYLON.Scene(engine)\n\n  initMap(scene, 100, 100)\n  initCamera(scene, canvas, 100, 100)\n\n  scene.createDefaultLight(true)\n  // scene.createDefaultEnvironment()\n\n  buildRoads(scene)\n  buildTrees(scene)\n\n  clickToBuildRoad(scene)\n  return scene\n\n}\n","import * as BABYLON from 'babylonjs'\nimport { store } from '@root/data/store'\n\nexport const initMap = (scene: BABYLON.Scene, mapWidth: number, mapHeight: number) => {\n\n  const ground = BABYLON.MeshBuilder.CreateGround(\n      'ground',\n      {width: mapWidth, height: mapHeight},\n      scene\n  )\n  const groundMaterial = new BABYLON.StandardMaterial('ground-material', scene)\n  groundMaterial.diffuseColor = new BABYLON.Color3(0.462, 0.76, 0.404)\n  ground.material = groundMaterial\n  ground.position = new BABYLON.Vector3(mapWidth / 2, 0, mapHeight / 2)\n\n  store.initMap(mapWidth, mapHeight)\n\n}\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","import * as BABYLON from 'babylonjs'\nimport { createTree } from '@root/model/tree'\nimport { random, range } from 'lodash'\nimport { store } from '@root/data/store'\nimport { MESH_TYPE } from '@root/model/type'\n\nlet baseTree: BABYLON.Mesh\n\nexport const buildTrees = (scene: BABYLON.Scene) => {\n\n  if (!baseTree) {\n    baseTree = createTree(scene)\n    scene.removeMesh(baseTree)\n  }\n\n  range(random(100, 300)).forEach(() => {\n    const tree = baseTree.clone()\n    const x = random(10, 90)\n    const z = random(10, 90)\n    if (store.map[x][z].mesh) {\n      scene.removeMesh(tree)\n    } else {\n      store.map[x][z].mesh = tree\n      store.map[x][z].meshType = MESH_TYPE.TREE\n      tree.position = new BABYLON.Vector3(x, 0, z)\n      tree.addRotation(0, random(0, Math.PI, true), 0)\n    }\n  })\n}\n","import * as BABYLON from 'babylonjs'\n\nexport const createTree = (scene: BABYLON.Scene) => {\n\n  const trunkMaterials = new BABYLON.StandardMaterial('trunk', scene)\n  trunkMaterials.diffuseColor = new BABYLON.Color3(0.37, 0.27, 0.207)\n\n  const leafMaterials = new BABYLON.StandardMaterial('leaf', scene)\n  leafMaterials.diffuseColor = new BABYLON.Color3(0.3, 0.45, 0.24)\n\n  const trunkHeight = 0.7\n  const leafHeight = 1.0\n\n  const trunk = BABYLON.MeshBuilder.CreateBox(\n      'trunk',\n      {size: 0.2, height: trunkHeight},\n      scene\n  )\n  trunk.material = trunkMaterials\n  trunk.position = new BABYLON.Vector3(0, trunkHeight / 2, 0)\n\n  const leaf = BABYLON.MeshBuilder.CreateBox(\n      'leaf',\n      {size: 0.6, height: leafHeight},\n      scene\n  )\n  leaf.material = leafMaterials\n  leaf.position = new BABYLON.Vector3(0, trunkHeight + leafHeight / 2 , 0)\n\n  return BABYLON.Mesh.MergeMeshes(\n      [trunk, leaf],\n      true,\n      true,\n      undefined,\n      false,\n      true\n  )\n}\n","import * as BABYLON from 'babylonjs'\n\nexport const initCamera = (\n    scene: BABYLON.Scene,\n    canvas: HTMLCanvasElement,\n    mapWidth: number,\n    mapHeight: number\n) => {\n  const camera = new BABYLON.ArcRotateCamera(\n      'Camera',\n      Math.PI / 4,\n      Math.PI / 180 * 50,\n      20,\n      new BABYLON.Vector3(mapWidth / 2, 0, mapHeight / 2),\n      scene\n  )\n\n  camera.attachControl(canvas, true)\n\n}\n","import * as BABYLON from 'babylonjs'\nimport { createRoad, ROAD_TYPE } from '@root/model/road'\nimport { store } from '@root/data/store'\nimport { MESH_TYPE } from '@root/model/type'\n\nconst initRoadData = () => {\n  store.road.forEach(([x, z]) => {\n    store.map[x][z].meshType = MESH_TYPE.ROAD\n  })\n}\n\nconst calculateRoadType = ([x, z]: [number, number]) => {\n  const around = [\n    store.map[x + 1][z].meshType,\n    store.map[x][z - 1].meshType,\n    store.map[x - 1][z].meshType,\n    store.map[x][z + 1].meshType,\n  ]\n\n  const roads = around.filter((type) => type === MESH_TYPE.ROAD)\n  const roadInfo = store.map[x][z].info as { type?: ROAD_TYPE, rotate?: number }\n\n  if (roads.length === 4) {\n    roadInfo.type = ROAD_TYPE.CROSSROAD\n  } else if (roads.length === 3) {\n    roadInfo.type = ROAD_TYPE.T_INTERSECTION\n    roadInfo.rotate = calculateRotationForTIntersection(around)\n  } else if (roads.length === 2) {\n    if (around[0] === MESH_TYPE.ROAD && around[2] === MESH_TYPE.ROAD) {\n      roadInfo.type = ROAD_TYPE.HORIZONTAL\n    } else if (around[1] === MESH_TYPE.ROAD && around[3] === MESH_TYPE.ROAD) {\n      roadInfo.type = ROAD_TYPE.VERTICAL\n    } else {\n      roadInfo.type = ROAD_TYPE.CONNER\n      if (around[0] === MESH_TYPE.ROAD && around[1] === MESH_TYPE.ROAD) {\n        roadInfo.rotate = Math.PI / 2\n      } else if (around[0] === MESH_TYPE.ROAD && around[3] === MESH_TYPE.ROAD) {\n        roadInfo.rotate = Math.PI * 2\n      } else if (around[1] === MESH_TYPE.ROAD && around[2] === MESH_TYPE.ROAD) {\n        roadInfo.rotate = Math.PI\n      } else if (around[2] === MESH_TYPE.ROAD && around[3] === MESH_TYPE.ROAD) {\n        roadInfo.rotate = Math.PI / 2 * 3\n      }\n    }\n\n  } else if (roads.length === 1) {\n    if (around[0] === MESH_TYPE.ROAD || around[2] === MESH_TYPE.ROAD) {\n      roadInfo.type = ROAD_TYPE.HORIZONTAL\n    } else {\n      roadInfo.type = ROAD_TYPE.VERTICAL\n    }\n  }\n\n}\n\nconst calculateRotationForTIntersection = (around: MESH_TYPE[]) => {\n  const isRoad = around.map((type) => type === MESH_TYPE.ROAD )\n  if (!isRoad[1]) {\n    return 0\n  }\n  if (!isRoad[2]) {\n    return Math.PI / 2\n  }\n  if (!isRoad[3]) {\n    return Math.PI\n  }\n  if (!isRoad[0]) {\n    return Math.PI / 2 * 3\n  }\n  return 0\n}\n\nexport const buildRoads = (scene: BABYLON.Scene) => {\n  initRoadData()\n\n  store.road.forEach(calculateRoadType)\n  store.road.forEach(([x, z]) => {\n    store.map[x][z].mesh = createRoad(\n        scene,\n        x,\n        z,\n        store.map[x][z].info.type,\n        store.map[x][z].info.rotate\n    )\n  })\n\n}\n\nconst rebuildRoad = (x: number, z: number, scene: BABYLON.Scene) => {\n  calculateRoadType([x, z])\n  if (store.map[x][z].mesh) {\n    store.map[x][z].mesh.dispose()\n  }\n  store.map[x][z].mesh = createRoad(\n    scene,\n    x,\n    z,\n    store.map[x][z].info.type,\n    store.map[x][z].info.rotate\n  )\n}\n\nconst rebuildSurroundingArea = (x: number, z: number, scene: BABYLON.Scene) => {\n  for (let i = x-1; i <= x+1; i++ ) {\n    for (let j = z-1; j <= z+1; j++) {\n      if(store.map[i][j].meshType === MESH_TYPE.ROAD) {\n        rebuildRoad(i, j, scene)\n      }\n    }\n  }\n}\n\nexport const clickToBuildRoad = (scene: BABYLON.Scene) => {\n  scene.onPointerObservable.add((pointerInfo: BABYLON.PointerInfo) => {\n    switch (pointerInfo.type) {\n        case BABYLON.PointerEventTypes.POINTERTAP:\n            const x: number = Math.round(pointerInfo.pickInfo.pickedPoint.x)\n            const z: number = Math.round(pointerInfo.pickInfo.pickedPoint.z)\n            store.map[x][z].meshType = MESH_TYPE.ROAD\n            rebuildSurroundingArea(x, z, scene)\n            break\n    }\n})\n\n}\n","import * as BABYLON from 'babylonjs'\n\nexport enum ROAD_TYPE {\n  HORIZONTAL,\n  VERTICAL,\n  CONNER,\n  T_INTERSECTION,\n  CROSSROAD,\n}\n\nexport const ROAD_NAME = 'road'\n\nconst createHorizontalRoad = (\n    scene: BABYLON.Scene,\n    [shoulderMaterials, roadBedMaterials]: [BABYLON.StandardMaterial, BABYLON.StandardMaterial]\n) => {\n  const shoulder = BABYLON.MeshBuilder.CreateBox(\n      'shoulder',\n      {\n        width: 1,\n        height: 0.02,\n        depth: 0.1,\n      },\n      scene\n  )\n  shoulder.material = shoulderMaterials\n  const rightShoulder = shoulder.clone()\n\n  const roadBed = BABYLON.MeshBuilder.CreatePlane(\n      'roadBed',\n      {\n        width: 1,\n        size: 0.8,\n      },\n      scene\n  )\n  roadBed.material = roadBedMaterials\n\n  shoulder.position = new BABYLON.Vector3(0, 0.01, -0.45)\n  rightShoulder.position = new BABYLON.Vector3(0, 0.01, 0.45)\n\n  roadBed.position = new BABYLON.Vector3(0, 0.001, 0)\n  roadBed.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0)\n\n  const road = BABYLON.Mesh.MergeMeshes(\n      [shoulder, rightShoulder, roadBed],\n      true,\n      true,\n      undefined,\n      false,\n      true\n  )\n  road.name = ROAD_NAME\n  return road\n}\n\nconst createConnerRoad = (\n    scene: BABYLON.Scene,\n    [shoulderMaterials, roadBedMaterials]: [BABYLON.StandardMaterial, BABYLON.StandardMaterial]\n) => {\n  const shoulder = BABYLON.MeshBuilder.CreateBox(\n      'shoulder',\n      {\n        width: 1,\n        height: 0.02,\n        depth: 0.1,\n      },\n      scene\n  )\n  shoulder.material = shoulderMaterials\n\n  const shoulderConner = BABYLON.MeshBuilder.CreateBox(\n      'shoulderConner',\n      {\n        width: 0.1,\n        height: 0.02,\n        depth: 0.1,\n      },\n      scene\n  )\n  shoulderConner.material = shoulderMaterials\n\n  const roadBed = BABYLON.MeshBuilder.CreatePlane(\n      'roadBed',\n      {\n        width: 0.9,\n        height: 0.9,\n      },\n      scene\n  )\n  roadBed.material = roadBedMaterials\n\n  shoulder.position = new BABYLON.Vector3(0, 0.01, -0.45)\n  const topShoulder = shoulder.clone()\n  topShoulder.rotation.y = Math.PI / 2\n  topShoulder.position = new BABYLON.Vector3(-0.45, 0.01, 0)\n  shoulderConner.position = new BABYLON.Vector3(0.45, 0.01, 0.45)\n\n  roadBed.position = new BABYLON.Vector3(0.05, 0.001, 0.05)\n  roadBed.rotation.x = Math.PI / 2\n\n  const road = BABYLON.Mesh.MergeMeshes(\n      [shoulder, topShoulder, roadBed, shoulderConner],\n      true,\n      true,\n      undefined,\n      false,\n      true\n  )\n  road.name = ROAD_NAME\n  return road\n}\n\nconst createTIntersectionRoad = (\n    scene: BABYLON.Scene,\n    [shoulderMaterials, roadBedMaterials]: [BABYLON.StandardMaterial, BABYLON.StandardMaterial]\n) => {\n  const shoulder = BABYLON.MeshBuilder.CreateBox(\n      'shoulder',\n      {\n        width: 1,\n        height: 0.02,\n        depth: 0.1,\n      },\n      scene\n  )\n  const shoulderConnerLeft = BABYLON.MeshBuilder.CreateBox(\n      'shoulderConnerLeft',\n      {\n        width: 0.1,\n        height: 0.02,\n        depth: 0.1,\n      },\n      scene\n  )\n  shoulder.material = shoulderMaterials\n  shoulderConnerLeft.material = shoulderMaterials\n\n  const shoulderConnerRight = shoulderConnerLeft.clone()\n\n  const roadBed = BABYLON.MeshBuilder.CreatePlane(\n      'roadBed',\n      {\n        width: 1,\n        height: 0.9,\n      },\n      scene\n  )\n  roadBed.material = roadBedMaterials\n\n  shoulder.position = new BABYLON.Vector3(0, 0.01, -0.45)\n  shoulderConnerLeft.position = new BABYLON.Vector3(0.45, 0.01, 0.45)\n  shoulderConnerRight.position = new BABYLON.Vector3(-0.45, 0.01, 0.45)\n\n  roadBed.position = new BABYLON.Vector3(0, 0.001, 0.05)\n  roadBed.rotation.x = Math.PI / 2\n\n  const road = BABYLON.Mesh.MergeMeshes(\n      [shoulder, shoulderConnerLeft, shoulderConnerRight, roadBed],\n      true,\n      true,\n      undefined,\n      false,\n      true\n  )\n  road.name = ROAD_NAME\n  return road\n}\n\nconst createCrossroadRoad = (\n    scene: BABYLON.Scene,\n    [shoulderMaterials, roadBedMaterials]: [BABYLON.StandardMaterial, BABYLON.StandardMaterial]\n) => {\n  const shoulderConnerA = BABYLON.MeshBuilder.CreateBox(\n      'shoulderConner',\n      {\n        width: 0.1,\n        height: 0.02,\n        depth: 0.1,\n      },\n      scene\n  )\n  shoulderConnerA.material = shoulderMaterials\n  const shoulderConnerB = shoulderConnerA.clone()\n  const shoulderConnerC = shoulderConnerA.clone()\n  const shoulderConnerD = shoulderConnerA.clone()\n\n  const roadBed = BABYLON.MeshBuilder.CreatePlane(\n      'roadBed',\n      {\n        width: 1,\n        height: 1,\n      },\n      scene\n  )\n  roadBed.material = roadBedMaterials\n\n  shoulderConnerA.position = new BABYLON.Vector3(0.45, 0.01, 0.45)\n  shoulderConnerB.position = new BABYLON.Vector3(-0.45, 0.01, 0.45)\n  shoulderConnerC.position = new BABYLON.Vector3(0.45, 0.01, -0.45)\n  shoulderConnerD.position = new BABYLON.Vector3(-0.45, 0.01, -0.45)\n\n  roadBed.position.y = 0.001\n  roadBed.rotation.x = Math.PI / 2\n\n  const road = BABYLON.Mesh.MergeMeshes(\n      [\n        roadBed,\n        shoulderConnerA,\n        shoulderConnerB,\n        shoulderConnerC,\n        shoulderConnerD,\n      ],\n      true,\n      true,\n      undefined,\n      false,\n      true\n  )\n  road.name = ROAD_NAME\n  return road\n\n}\n\nexport const createRoad = (\n    scene: BABYLON.Scene,\n    x: number,\n    z: number,\n    type: ROAD_TYPE = ROAD_TYPE.HORIZONTAL,\n    rotate: number = 0\n) => {\n\n  const shoulderMaterials = new BABYLON.StandardMaterial('shoulder', scene)\n  shoulderMaterials.diffuseColor = new BABYLON.Color3(0.83, 0.79, 0.77)\n\n  const roadBedMaterials = new BABYLON.StandardMaterial('roadBed', scene)\n  roadBedMaterials.diffuseColor = new BABYLON.Color3(0.43, 0.42, 0.44)\n\n  let road: BABYLON.Mesh\n\n  if ([ROAD_TYPE.HORIZONTAL, ROAD_TYPE.VERTICAL].includes(type)) {\n    road = createHorizontalRoad(scene, [shoulderMaterials, roadBedMaterials])\n    if (type === ROAD_TYPE.VERTICAL) {\n      road.rotation.y = Math.PI / 2\n    }\n  }\n\n  if (ROAD_TYPE.CONNER === type) {\n    road = createConnerRoad(scene, [shoulderMaterials, roadBedMaterials])\n  }\n\n  if (ROAD_TYPE.T_INTERSECTION === type) {\n    road = createTIntersectionRoad(scene, [shoulderMaterials, roadBedMaterials])\n  }\n\n  if (ROAD_TYPE.CROSSROAD === type) {\n    road = createCrossroadRoad(scene, [shoulderMaterials, roadBedMaterials])\n  }\n\n  if (rotate) {\n    road.rotation.y = rotate\n  }\n\n  road.position = new BABYLON.Vector3(x, 0, z)\n\n  return road\n}\n"],"sourceRoot":""}